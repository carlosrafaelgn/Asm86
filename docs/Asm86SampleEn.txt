({emulatorVersion:1,code:";-------------------------------------------------------------------------\n; Port map\n;-------------------------------------------------------------------------\n;\n; Timing\n; 0x00 0x01 0x02 0x03 (LSB ... MSB) = current system time in ms (ports 0, 1, 2 and 3 are updated when port 0 is read) (RO)\n; 0x04 0x05 0x06 0x07 (LSB ... MSB) = timer interval in ms (used to start timers 0, 1, 2 and 3) (RW)\n; 0x08 = timer 0 on/off (0 stops the timer, while any other value either starts or restarts it) (RW)\n; 0x09 = timer 1 on/off (0 stops the timer, while any other value either starts or restarts it) (RW)\n; 0x0A = timer 2 on/off (0 stops the timer, while any other value either starts or restarts it) (RW)\n; 0x0B = timer 3 on/off (0 stops the timer, while any other value either starts or restarts it) (RW)\n;\n; Buttons and lighting\n; 0xE0 = number of the button which has been pressed/released (0 ... 15) (RO)\n; 0xE1 = current state of the toggled button (0 = released, 1 = pressed) (RO)\n; 0xE2 = light bulbs' state (bit 0 controls bulb 0 ...) (RW)\n;\n; EEPROM\n; 0xE3 = EEPROM address (by changing address, if OE = 1, data is updated with actual EEPROM's contents) (RW)\n; 0xE4 = EEPROM data (if OE = 1 writings are ignored) (RW)\n; 0xE5 = EEPROM control (RW)\n;        bit 0 = Not WR (by toggling from 1 to 0, data's contents is stored into the EEPROM)\n;        bit 1 = OE (OE = 1 makes data RO, while 0 makes it RW)\n;\n; Console\n; 0xE6 = general purpose value (RW)\n;\t\t - maximum amount of characters that the user is allowed to enter with command 1\n;\t\t - amount of characters to send to the console with command 3\n;\t\t - color component for commands 6 ... 11\n; 0xE7 = general purpose value (RW)\n;\t\t - row index for commands 5 ... 11\n; 0xE8 = control commands (RW)\n;\t\t 0 = hides the console input\n;\t\t 1 = shows the console input\n;\t\t 2 = clears the console's memory\n;\t\t 3 = sends the text pointed by 0xEC to console's memory (a 0 character stops the process, even if the value at 0xE6 is greater)\n;\t\t 4 = copies the contents of the console's memory to the screen\n;\t\t 5 = copies the contents of the given row, from the console's memory to the screen\n;\t\t 6, 7, 8 = specifies the R, G or B component for the given row's background color\n;\t\t 9, 10, 11 = specifies the R, G or B component for the given row's text color\n; 0xE9 = amount of characters typed by the user (this value is set to 0 by commands 0 and 1) (RO)\n; 0xEA = cursor's X position (0 ... 79) (RW)\n; 0xEB = cursor's Y position (0 ... 19 or 20, when Y = 20, the next character written to the screen causes it to scroll) (RW)\n; 0xEC 0xED 0xEE 0xEF (LSB ... MSB) = address where to fetch the text to be sent/to store the text typed by the user (RW)\n;\n; Reset\n; 0xFF = system reset (writing a value other than 0 resets the processor and finishes the execution) (WO)\n;\n;-------------------------------------------------------------------------\n; External interrupt map\n;-------------------------------------------------------------------------\n; 0x20 = timer 0\n; 0x21 = timer 1\n; 0x22 = timer 2\n; 0x23 = timer 3\n; 0x30 = buttons\n; 0x31 = console's input OK button\n;\n;-------------------------------------------------------------------------\n; Instructions for storing the context\n;-------------------------------------------------------------------------\n; XSAVE mem = stores the processor's state at the memory pointed to by mem (requires at least 36 bytes)\n; XRSTOR mem = loads the processor's state from the memory pointed to by mem (requires at least 36 bytes)\n; Instru\u00e7\u00e3o XSAVE stores the registers in the following order: EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP, FLAGS\n;-------------------------------------------------------------------------\n\n;---------------------------------------------------------------------------\n; Execution always starts at the first valid line\n;---------------------------------------------------------------------------\n\t; Set up the screen\n\tlea eax, info ; Print all the instructions\n\tout 0xEC, eax\n\tmov eax, 0x0300FF\n\tout 0xE6, eax\n\tmov ax, 0x1300 ; Move the cursor to 0,19\n\tout 0xEA, ax\n\tlea eax, info2 ; Print the footer\n\tout 0xEC, eax\n\tmov eax, 0x0300FF\n\tout 0xE6, eax\n\tmov eax, 0x090700 ; Row 7's text color's R component\n\tout 0xE6, eax\n\tmov eax, 0x0A07BB ; Row 7's text color's G component\n\tout 0xE6, eax\n\tmov eax, 0x0B0700 ; Row 7's text color's B component\n\tout 0xE6, eax\n\tmov eax, 0x061344 ; Row 19's background color's R component\n\tout 0xE6, eax\n\tmov eax, 0x0713AA ; Row 19's background color's G component\n\tout 0xE6, eax\n\tmov eax, 0x0813FF ; Row 19's background color's B component\n\tout 0xE6, eax\n\tmov eax, 0x091300 ; Row 19's text color's R component\n\tout 0xE6, eax\n\tmov eax, 0x0A1300 ; Row 19's text color's G component\n\tout 0xE6, eax\n\tmov eax, 0x0B1300 ; Row 19's text color's B component\n\tout 0xE6, eax\n\tmov al, 4 ; Update the entire screen at once\n\tout 0xE8, al\n\t; Wait for the user to choose the test:\n\t; 1 = Timer, interrupts and lighting test\n\t; 2 = Buttons and lighting test\n\t; 3 = Random lighting test\nWAIT_FOR_BUTTON:\n\thlt\n\tin ax, 0xE0\n\tcmp ax, 0x0001 ; Button 1 released\n\tje TEST1\n\tcmp ax, 0x0002 ; Button 2 released\n\tje TEST2\n\tcmp ax, 0x0003 ; Button 3 released\n\tje TEST3\n\tcmp ah, 0\n\tjne WAIT_FOR_BUTTON\n\tint 3 ; Call the debugger to let us know that no valid button has been pressed\n\tjmp WAIT_FOR_BUTTON\nSHUT_DOWN:\n\t; Sending any byte other than 0 to port 255 finishes the execution\n\tmov al, 1\n\tout 255, al\n;---------------------------------------------------------------------------\n; Test 1 = Timer, interrupts and lighting test\n;---------------------------------------------------------------------------\nTEST1:\n\tmov eax, 0x0902FF ; Row 2's text color's R component\n\tout 0xE6, eax\n\tmov eax, 0x0A0244 ; Row 2's text color's G component\n\tout 0xE6, eax\n\tmov eax, 0x0B02DD ; Row 2's text color's B component\n\tout 0xE6, eax\n\tmov ax, 0x0502 ; Update row 2 on the screen\n\tout 0xE7, ax\n\t\n\tmov eax, 10000 ; Set up timer 0 for 10 seconds\n\tout 4, eax\n\t\n\tmov al, 0b00110011\n\tout 0xE2, al\n\tmov al, 1\n\tout 8, al\n\thlt ; Any interrupt will make the processor move on to the next instruction\n\t\n\tmov al, 0b11001100\n\tout 0xE2, al\n\tmov al, 1\n\tout 8, al\n\tcall WAIT_FOR_TIMER\n\t\n\tmov eax, 1000 ; Set up timer 0 for 1 second\n\tout 4, eax\n\t\n\tmov al, 0b01010101\n\tout 0xE2, al\n\tmov al, 1\n\tout 8, al\n\thlt\n\t\n\tmov al, 0b10101010\n\tout 0xE2, al\n\tmov al, 1\n\tout 8, al\n\thlt\n\t\n\t; Before shutting down, blink 10 times\n\tmov ecx, 10\n\t\n\tmov eax, 75 ; Set up timer 0 for 75 ms\n\tout 4, eax\nBLINK:\n\tmov al, 0b11111111\n\tout 0xE2, al\n\tmov al, 1\n\tout 8, al\n\thlt\n\tmov al, 0b00000000\n\tout 0xE2, al\n\tmov al, 1\n\tout 8, al\n\thlt\n\t; Two ways to achieve the same result\n\t;dec ecx\n\t;jnz BLINK\n\tloop BLINK\n\tjmp SHUT_DOWN\nWAIT_FOR_TIMER:\n\tin al, 8 ; Verifica o estado do timer\n\ttest al, al\n\tjz WAIT_FOR_TIMER_END\n\thlt\n\tjmp WAIT_FOR_TIMER\nWAIT_FOR_TIMER_END:\n\tret\n;---------------------------------------------------------------------------\n; Test 2 = Buttons and lighting test\n;---------------------------------------------------------------------------\nTEST2:\n\tmov eax, 0x0903FF ; Row 3's text color's R component\n\tout 0xE6, eax\n\tmov eax, 0x0A0344 ; Row 3's text color's G component\n\tout 0xE6, eax\n\tmov eax, 0x0B03DD ; Row 3's text color's B component\n\tout 0xE6, eax\n\tmov ax, 0x0503 ; Update row 3 on the screen\n\tout 0xE7, ax\n\t\n\tlea eax, IDT ; Set up the IDT\n\tmov [eax+0x20*4], INT_GEN\n\tmov [eax+0x30*4], INT_KEY2\n\tlidt eax\n\tsti\n_HLT:\n\thlt\n\tjmp _HLT\nINT_GEN:\n\tiret\nINT_KEY2:\n\tin al, 0xE0\n\tout 0xE2, al\n\tcmp al, 0\n\tje SHUT_DOWN\n\tiret\n;---------------------------------------------------------------------------\n; Op\u00e7\u00e3o 3\n;---------------------------------------------------------------------------\nTEST3:\n\tmov eax, 0x0904FF ; Row 4 text color's R component\n\tout 0xE6, eax\n\tmov eax, 0x0A0444 ; Row 4 text color's G component\n\tout 0xE6, eax\n\tmov eax, 0x0B04DD ; Row 4 text color's B component\n\tout 0xE6, eax\n\tmov ax, 0x0504 ; Update row 4 on the screen\n\tout 0xE7, ax\n\t\n\tlea eax, IDT ; Set up the IDT\n\tmov [eax+0x20*4], INT_GEN\n\tmov [eax+0x30*4], INT_KEY3\n\tlidt eax\n\tsti\n\tin eax, 0x00 ; Use the current system time as the seed for the random numbers\n\tmov ecx, 1103515245\n\tmov ebx, 1 ; Use EBX as the pause control\nLOOPING3:\n\tout 0xE2, al\n\timul ecx ; Generates another pseudo-random number\n\tadd eax, 12345\n\tcmp ebx, 0\n\tje PAUSE_LOOPING3\n\tjmp LOOPING3\nPAUSE_LOOPING3:\n\thlt\n\tcmp ebx, 0\n\tjne LOOPING3\n\tjmp PAUSE_LOOPING3\nINT_KEY3:\n\tin ax, 0xE0\n\tcmp ax, 0x0000 ; Button 0 has been released\n\tje SHUT_DOWN\n\tcmp ax, 0x0001 ; Button 1 has been released\n\tjne INT_KEY3_END\n\txor ebx, 1\nINT_KEY3_END:\n\tiret\n\t",variables:[],eeprom:[]})